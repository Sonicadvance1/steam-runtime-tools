#!/bin/sh

# pressure-vessel — use containers for Steam
#
# Copyright © 2017-2018 Collabora Ltd.
#
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set -e
set -u

me="$0"
me="${me##*/}"

# Undo any weird environment before we start running external
# executables. We put it back before running the actual app/game.

caller_ld_preload="${LD_PRELOAD:-}"
unset LD_PRELOAD

caller_ld_library_path="${LD_LIBRARY_PATH:-}"

if [ -n "${SYSTEM_LD_LIBRARY_PATH-}" ]; then
    export LD_LIBRARY_PATH="$SYSTEM_LD_LIBRARY_PATH"
else
    unset LD_LIBRARY_PATH
fi

caller_path="${PATH:-"${default_path}"}"
default_path="/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"

if [ -n "${SYSTEM_PATH-}" ]; then
    export PATH="$SYSTEM_PATH"
else
    export PATH="$default_path"
fi

# If bwrap isn't installed as a standalone binary on the PATH, see
# whether we have a copy of Flatpak configured with the bundled
# bubblewrap (--without-system-bubblewrap). If we do, use that one.
if [ -z "${BWRAP:-}" ]; then
    if ! BWRAP="$(command -v bwrap)"; then
        for dir in /usr/local/libexec /usr/libexec /usr/lib/flatpak; do
            if [ -x "$dir/flatpak-bwrap" ]; then
                BWRAP="$dir/flatpak-bwrap"
                break
            fi
        done
    fi
fi

if [ -z "$BWRAP" ] || ! "$BWRAP" --bind / / true; then
    echo "$me: cannot find bwrap or it doesn't work, falling back to executing '$*' directly" >&2

    if [ -n "$caller_ld_preload" ]; then
        export LD_PRELOAD="$caller_ld_preload"
    fi
    if [ -n "$caller_path" ]; then
        export PATH="$caller_path"
    fi
    if [ -n "$caller_ld_library_path" ]; then
        export LD_LIBRARY_PATH="$caller_ld_library_path"
    else
        unset LD_LIBRARY_PATH
    fi

    exec "$@"
fi

fake_home=
interactive=
verbose=

# Pop the pressure-vessel-wrap options from $@, leaving the command
# and arguments.

usage () {
    code="$1"
    shift

    if [ "$code" -ne 0 ]; then
        exec >&2
    fi

    echo
    echo "Usage: $me [OPTIONS] [--] COMMAND [ARGS...]"
    echo
    echo "Run COMMAND [ARGS...] in a container that protects \$HOME."
    echo
    echo "The current working directory will be writeable for COMMAND,"
    echo "unless it is the real home directory."
    echo
    echo "Options:"
    echo "--steam-app-id=123            Use ~/.var/app/com.steampowered.App123"
    echo "                              as home directory."
    echo "                              [Default: \$SteamAppId]"
    echo "--freedesktop-app-id=ID       Use ~/.var/app/ID as home directory."
    echo "                              ID is com.example.MyApp or similar."
    echo "                              This interoperates with Flatpak."
    echo "--home=HOME                   Use HOME as home directory."
    echo
    echo "--interactive                 Run an interactive shell instead of"
    echo "                              COMMAND. Executing \"\$@\" in that"
    echo "                              shell will run COMMAND [ARGS]."
    echo "--verbose                     Be more verbose."
    echo

    exit "$code"
}

getopt_temp="$(getopt -o '' --long \
    'freedesktop-app-id:,help,home:,interactive,steam-app-id:,verbose' \
    -n "$me" -- "$@")"

eval set -- "$getopt_temp"
unset getopt_temp

while [ "$#" -gt 0 ]; do
    case "$1" in
        (--freedesktop-app-id)
            fake_home="$HOME/.var/app/$2"
            shift 2
            ;;

        (--steam-app-id)
            fake_home="$HOME/.var/app/com.steampowered.App$2"
            shift 2
            ;;

        (--home)
            fake_home="$2"
            shift 2
            ;;

        (--interactive)
            interactive=yes
            shift
            ;;

        (--verbose)
            verbose=yes
            shift
            ;;

        (--help)
            usage 0
            # not reached
            ;;

        (--)
            shift
            break
            ;;

        (--*)
            echo "$me: unknown option: $1" >&2
            usage 2
            # not reached
            ;;

        (*)
            break
            ;;
    esac
done

if [ "$#" -eq 0 ]; then
    echo "$me: an executable to run is required" >&2
    exit 2
fi

if "$BWRAP" --help | grep -F '[--]' 2>/dev/null; then
    bwrap_end_of_options="--"
else
    # bwrap doesn't support the -- syntax
    bwrap_end_of_options=""
    case "$1" in
        (-*)
            case "$1" in
                (*=*)
                    # env would interpret this as an environment variable
                    echo "$me: Cannot execute command '$1' with bubblewrap < 0.2.2">&2
                    exit 1
                    ;;
                (*)
                    # Emulate it via env(1)
                    bwrap_end_of_options="env"
                    ;;
            esac
            ;;
    esac
fi

if [ -n "$interactive" ]; then
    exec </dev/tty
    exec >/dev/tty
    exec 2>/dev/tty
    echo "$me: Starting interactive shell (original command is in \"\$@\")">&2
    set -- bash -i -s "$@"
fi

if [ -z "$fake_home" ]; then
    if [ -n "${SteamAppId:-}" ]; then
        fake_home="$HOME/.var/app/com.steampowered.App$SteamAppId"
    else
        echo "$me: either --home, --freedesktop-app-id, --steam-app-id" \
            "or \$SteamAppId is required" >&2
        exit 2
    fi
fi

# Because this is a shell script, we only have access to one array, which
# is $@; so we need to build up the bwrap command line backwards, with
# "wider" mount points like / coming after "narrower" mount points
# like $HOME.

# Protect the controlling terminal from the app/game, unless we are
# running an interactive shell in which case that would break its
# job control.
if [ -z "$interactive" ]; then
    set -- --new-session "$@"
fi

# Put the caller's LD_PRELOAD and search paths back.
if [ -n "$caller_ld_preload" ]; then
    set -- --setenv LD_PRELOAD "$caller_ld_preload" "$@"
else
    set -- --unsetenv LD_PRELOAD "$@"
fi
if [ -n "$caller_path" ]; then
    set -- --setenv PATH "$caller_path" "$@"
fi
if [ -n "$caller_ld_library_path" ]; then
    set -- --setenv LD_LIBRARY_PATH "$caller_ld_library_path" "$@"
else
    set -- --unsetenv LD_LIBRARY_PATH "$@"
fi

# Make sure the current working directory (the game we are going to
# run) is available. Some games write here.
PWD="$(pwd)"
if test "$HOME" -ef "$PWD"; then
    echo "$me: Not making real $PWD available to container because it is" \
         "the home directory" >&2
else
    set -- --bind "$PWD" "$PWD" "$@"
fi
set -- --chdir "$PWD" "$@"

# We need libraries from the Steam Runtime, so make sure that's visible
# (it should never need to be read/write though)
if [ -n "${STEAM_RUNTIME:-}" ]; then
    set -- --ro-bind "$STEAM_RUNTIME" "$STEAM_RUNTIME" "$@"
fi

# We need the LD_PRELOADs from Steam visible at the paths that were
# used for them, which might be their physical rather than logical
# locations
old_ifs="$IFS"
IFS=:
for preload in $caller_ld_preload; do
    if [ -e "$preload" ]; then
        set -- --ro-bind "$preload" "$preload" "$@"
    fi
done
IFS="$old_ifs"

# These might be API entry points, according to .steam/steam/steam.sh.
# On the host system they're symlinks to a real location, but in a
# container it's easier to bind-mount them (this follows symlinks).
# TODO: We probably want to hide part or all of root, steam, steambeta?
for api in bin bin32 bin64 root sdk32 sdk64 steam steambeta; do
    dir="$HOME/.steam/$api"
    if [ -d "$dir" ]; then
        set -- --ro-bind "$dir" "$dir" "$@"
    fi
done

# steamclient.so relies on this for communication with Steam
if [ -e "$HOME/.steam/steam.pid" ]; then
    set -- --ro-bind "$HOME/.steam/steam.pid" "$HOME/.steam/steam.pid" "$@"
fi

# Make sure Steam IPC is available (TODO: do we need this? do we need more?)
if [ -e "$HOME/.steam/steam.pipe" ]; then
    set -- --bind "$HOME/.steam/steam.pipe" "$HOME/.steam/steam.pipe" "$@"
fi

# The shellcheck tool warns that -m is only applied to the deepest
# directory and not any parents created via -p, but that's fine here:
# we use a separate mkdir -p for each directory whose permissions we
# care about.
# shellcheck disable=SC2174
{
    # Set up the home directory
    mkdir -m700 -p "$fake_home"
    set -- --bind "$fake_home" "$HOME" --bind "$fake_home" "$fake_home" "$@"

    # Set up /var/tmp, XDG_*_HOME like Flatpak does
    mkdir -m700 -p "$fake_home/cache"
    mkdir -m700 -p "$fake_home/cache/tmp"
    set -- --bind "$fake_home/cache/tmp" /var/tmp "$@"
    set -- --setenv XDG_CACHE_HOME "$fake_home/cache" "$@"
    mkdir -m700 -p "$fake_home/config"
    set -- --setenv XDG_CONFIG_HOME "$fake_home/config" "$@"
    mkdir -m700 -p "$fake_home/data"
    set -- --setenv XDG_DATA_HOME "$fake_home/data" "$@"
}

# Protect other users' homes (but guard against the unlikely situation
# that they don't exist)
if [ -d /home ]; then
    set -- --tmpfs /home "$@"
fi

# Make /dev available
if [ -d /dev/pts ]; then
    set -- --bind /dev/pts /dev/pts "$@"
fi
if [ -d /dev/shm ]; then
    set -- --bind /dev/shm /dev/shm "$@"
fi
set -- --dev-bind /dev /dev "$@"

# Everything else comes from the root filesystem for now
set -- --bind / / "$@"

if "$BWRAP" --help | grep unshare-uts >/dev/null; then
    # Set a standard hostname for the container to make it easier
    # to see which shell is which
    set -- --hostname pressure-vessel --unshare-uts "$@"
fi

# Potential future expansion: use --unshare-pid for more isolation

# Replace this process with bwrap, which replaces itself with the
# desired command (unless exec fails)
if [ -n "$verbose" ]; then
    echo "$me: '$BWRAP $*'" >&2
fi

exec "$BWRAP" $bwrap_end_of_options "$@" || e=$?
echo "$me: failed to execute '$BWRAP $*': exec status $e" >&2
exit "$e"
