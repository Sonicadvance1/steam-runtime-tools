#!/bin/bash

set -e;
set -u;

libexec=$(dirname $0);
me=$(basename $0);

usage ()
{
cat << EOF
Usage: $me [OPTIONS] TARGET [TREE [PROJECT-NAME]]
    Options:
        --capsule-symbols-tool=PATH
                                Use replacement capsule-symbols(1)
                                [default: ${CAPSULE_SYMBOLS_TOOL:-"$libexec/capsule-symbols"}]
        --capsule-version-tool=PATH
                                Use replacement capsule-version(1)
                                [default: ${CAPSULE_VERSION_TOOL:-"$libexec/capsule-version"}]
    Positional parameters:
        TARGET                  SONAME of the library to be proxied
        TREE                    Chroot or container to find libraries in,
                                both now and at runtime [default: /host]
        PROJECT-NAME            Project to create [default: libfoo-proxy]
EOF
    exit "${1:-0}"
}

getopt_temp="$(getopt -o 'h' \
    -l 'capsule-symbols-tool,capsule-version-tool,help' \
    -n "$me" -- "$@")"
eval set -- "$getopt_temp"

while true;
do
    case "$1" in
        (--help|-h)
            usage 0;
            ;;

        (--capsule-symbols-tool)
            CAPSULE_SYMBOLS_TOOL="$2"
            shift 2;
            continue;
            ;;

        (--capsule-version-tool)
            CAPSULE_VERSION_TOOL="$2"
            shift 2;
            continue;
            ;;

        (--)
            shift;
            break;
            ;;
        (*)
            echo "$me: Internal error" >&2;
            usage 2 >&2;
            ;;
    esac
done

if [ "$#" -lt 1 ] || [ "$#" -gt 3 ];
then
    usage 2 >&2;
fi;

target=$1;
tree=${2:-/host};

base=${target%%.so.*};
base=${base%.so};
name=${base#lib};
lcbase=${base,,};

dest=${3:-$base-proxy};
ver=0;
maj=0;

: "${CAPSULE_SYMBOLS_TOOL:="$libexec/capsule-symbols"}"
: "${CAPSULE_VERSION_TOOL:="$libexec/capsule-version"}"

read x x ver x < <("$CAPSULE_VERSION_TOOL" "$target" "$tree");

maj=${ver%%.*};

echo Generating project for $tree : $target $ver proxy;

echo Creating project directory $dest;

mkdir -p "$dest";
cd $dest;
mkdir -p shim;

echo Working in $PWD;

cat - <<EOF > README
This is a libcapsule based proxy library.

Its purpose is to allow a library ($target) to be loaded from a
foreign filesystem tree ($tree) without exposing any other libraries
from that tree to the program using it.

You can export the symbols of more than one library via the proxy:
To do so, add a line containing the bare (libFOO.so.X format) name 
of each extra library to shim/lib@LIB@.so.c.shared and rebuild.

You can also prevent a library from the foreign tree from being loaded
at all (at least as a result of being a dependency of lib@LIB@): 
To achieve this, add a line containing the bare (libFOO.so.X) name
of the excluded library to shim/lib@LIB@.so.c.excluded and rebuild.

The generated library will have the same name as the main proxy target
($target). You can control the exact version number (cf libfoo.x.y.z)
by setting CAPSULE_VERSION in Makefile.am
EOF

echo Extracting dynamic symbols from $tree : $target;

"$CAPSULE_SYMBOLS_TOOL" "$target" "$tree" > "shim/$base.so.symbols";

echo Preparing proxy source files
touch shim/$base.so.c.{shared,excluded};

cat - <<EOF > shim/$base.so.c.dlopen
static void *_int_dlopen (const char *filename, int flag)
{
    if( flag & RTLD_GLOBAL )
    {
        fprintf( stderr, "Warning: libcapsule dlopen wrapper cannot pass "
                         "RTLD_GLOBAL to underlying dlmopen(%s...) call\\n",
                 filename );
        flag = (flag & ~RTLD_GLOBAL) & 0xfffff;
    }
    return capsule_shim_dlopen( cap, filename, flag );
}

static void *_ext_dlopen (const char *filename, int flag)
{
    char *capsule_error = NULL;
    void *handle = capsule_external_dlopen( cap, filename, flag );
    capsule_relocate_except( cap, dl_relocs,
                             &invalid_dl_reloc_targets[0],
                             &capsule_error );
    if( capsule_error )
    {
        fprintf( stderr, "post-dlopen hook secondary relocate failed: %s\n",
                 capsule_error );
        free( capsule_error );
        capsule_error = NULL;
    }
    return handle;
}
EOF

cat - <<EOF > shim/$base.so.c.dlsym
// This allows symbols inside the capsule to be found by dlopen calls from
// outside the capsule iff they are in one of the exported DSOs.
//
// This is useful in libGL shims as libGL has an ‘interesting’ history
// of symbols appearing and disappearing so its users often do a
// bizarre dlopen()/dlsym() dance instead of referring to a symbol
// directly (and we may be missing those symbols from our static
// export list even if the target libGL has them)
static void *_dlsym (void *handle, const char *symbol)
{
    return capsule_external_dlsym( cap, handle, symbol );
}
EOF

echo Initialising configure.ac;

cat - <<EOF > configure.ac
AC_INIT($lcbase-proxy, $ver)
AC_CONFIG_MACRO_DIR([m4])

dnl basename of the main library we are proxying for:
AC_SUBST([LIB],[$name])
AC_SUBST([MAJ],[$maj])

dnl don't kvetch about gnu makefile syntax
dnl and don't require ChangeLog &co if they don't exist
AM_INIT_AUTOMAKE([-Wno-portability foreign])
AM_SILENT_RULES([yes])
LT_INIT

PKG_CHECK_MODULES([CAPSULE], [capsule])
PKG_CHECK_VAR([CAPSULE_MKINC], [capsule], [makeinc])

AC_CONFIG_FILES([capsule-shim.mk:\$CAPSULE_MKINC/capsule-shim.mk.in Makefile])
AC_OUTPUT()
EOF

echo Initialising Makefile.am;

cat - <<EOF > Makefile.am
CAPSULE_LIBRARY := $name
CAPSULE_VERSION := $ver
CAPSULE_TREE    := $tree
CAPSULE_MAJOR   := $maj

include @CAPSULE_MKINC@/disabled.mk
##include capsule-shim.mk##
EOF

echo Bootstrapping autoconf templates for $target;

############################################################################
# this stage generates the capsule-shim.mk from a template, which
# we need to be in place before we generate the _real_ Makefile.in:
if ! (autoreconf -if;
 ./configure;
 sed -i -re 's@##(include .*)##@\1@' Makefile.am) > preconfigure.log 2>&1;
then
    cat preconfigure.log
    exit 1
fi
############################################################################

echo Running initial configuration;
autoreconf -ivf

echo $PWD is ready for ./configure, see README for details;

