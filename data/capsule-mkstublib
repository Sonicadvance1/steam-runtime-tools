#!/bin/bash

# Copyright Â© 2017 Collabora Ltd

# This file is part of libcapsule.

# libcapsule is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of the
# License, or (at your option) any later version.

# libcapsule is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with libcapsule.  If not, see <http://www.gnu.org/licenses/>.

set -u
set -e

major_version=0;

parse_ltver ()
{
    major_version=${1%%:*};
}

declare -A NODE;
top=$(dirname $0);
top=${top:-.};
me=$(basename $0);

usage ()
{
cat << EOF
Usage: $me [OPTIONS] TARGET EXCLUDES EXPORTS OUTPUT DSO-VERSION TREE"
    Options:
        --capsule-symbols=PATH  Use replacement capsule-symbols(1)
    Positional parameters:
        TARGET                  SONAME of shared library to proxy,
                                for example libGL.so.1
        EXCLUDES                List of SONAMEs never loaded from TREE
                                in addition to libdl.so.2
        EXPORTS                 List of extra SONAMEs whose symbols are
                                to be exported from the shim, in addition
                                to TARGET itself
        OUTPUT                  C source code filename to output,
                                for example libGL.so.c
        DSO-VERSION             Major or MAJOR:MINOR:MICRO version (as for
                                libtool -version-number) to export, for
                                example 1 or 1:x:y for libGL.so.1
        TREE                    Chroot or container to find libraries in
EOF
    exit "${1:-0}"
}

getopt_temp="$(getopt -o 'h' \
    -l 'capsule-symbols:,help' \
    -n "$me" -- "$@")"
eval set -- "$getopt_temp"

while true;
do
    case "$1" in
        (--capsule-symbols)
            CAPSULE_SYMBOLS="$2"
            shift 2;
            continue;
            ;;

        (--help|-h)
            usage 0;
            ;;

        (--)
            shift;
            break;
            ;;
        (*)
            echo "$me: Internal error" >&2;
            usage 2 >&2;
            ;;
    esac
done

: "${CAPSULE_SYMBOLS:="$top/capsule-symbols"}"

if [ "$#" -ne 6 ];
then
    usage 2 >&2;
fi;

proxied_dso=$1;    shift;
proxy_excluded=$1; shift;
proxy_extra=$1;    shift;
proxy_src=$1;      shift;
ltver=$1;          shift;
proxy_tree=$1;     shift;

parse_ltver $ltver;

dso_base=${proxied_dso#lib}
dso_base=${dso_base%.so*}
proxied_dso=lib${dso_base}.so.${major_version};

symbol_file=${proxy_src%.c}.symbols;
map_file=${proxy_src%.c}.map;
dlopen_file=${proxy_src}.dlopen;
dlsym_file=${proxy_src}.dlsym;
sharedir=$(pkg-config --variable=makeinc capsule)

exec >$proxy_src.tmp;

cat $sharedir/capsule-shim.h

# generate the .symbols file if it doesn't exist, or if the proxy_extra
# control file has been updated:
if [ $symbol_file -ot $proxy_extra ];
then
    echo -n > $symbol_file;
    if (for pt in $proxied_dso $(cat $proxy_extra);
        do
            if [ x$V = x1 ];
            then
                echo "  $CAPSULE_SYMBOLS $pt $proxy_tree" >&2;
            else
                echo "  SYMBOLS $pt $proxy_tree" >&2;
            fi;
            $CAPSULE_SYMBOLS $pt $proxy_tree || exit 1;
        done) > $symbol_file.tmp;
    then
        mv $symbol_file.tmp $symbol_file;
    else
        code=$?;
        rm $symbol_file.tmp
        exit $code;
    fi;
fi;


while read symbol version dependency;
do
    case $version in
        @*)
            echo "VERSIONED_STUB  ( $symbol, $version );";
            node=${version##*@};
            NODE[$node]=${NODE[$node]:-}" "$symbol;
            ;;
        *)
            echo "UNVERSIONED_STUB( $symbol );";
            ;;
    esac;
done < $symbol_file;

cat - <<EOF
static Lmid_t symbol_ns;
static const char *prefix;
static void *dso;
// should we exclude libpthread here?
// in any case, these are DSOs we do _not_ want to isolate
static const char *exclude[] = { // MUST NOT be pulled from the capsule
                                 // prefixed filesystem tree:
                                 "libdl.so.2",
EOF

while read excluded x;
do
    case $excluded in lib*) printf "%32s \"%s\",\n" "" $excluded; ;; esac;
done < $proxy_excluded;
cat - <<EOF
                                 NULL };
EOF

if [ -f ${dlopen_file} ];
then
    echo "// -------------------------------------------------------------";
    echo "// start of ${proxy_src%.c} dlopen wrapper";
    cat $dlopen_file;
    echo "// end of ${proxy_src%.c} dlopen wrapper";
    echo "// -------------------------------------------------------------";
fi

if [ -f ${dlsym_file} ];
then
    echo "// DSOs to restrict dlsym lookups to:";
    echo "static const char *valid_dlsym_sources[] = ";
    echo "{";
    for pt in $proxied_dso $(cat $proxy_extra);
    do
        echo "  \"$pt\",";
    done;
    echo "  NULL";
    echo "};";

    echo "// -------------------------------------------------------------";
    echo "// start of ${proxy_src%.c} dlsym wrapper";
    cat $dlsym_file;
    echo "// end of ${proxy_src%.c} dlsym wrapper";
    echo "// -------------------------------------------------------------";
fi

cat - <<EOF

static void __attribute__ ((constructor)) _capsule_init (void)
{
    int   capsule_errno = 0;
    char *capsule_error = NULL;

    // this is an array of the functions we want to act as a shim for:
    capsule_item relocs[] =
      {
EOF

while read sym x; do echo "         { \"$sym\" },"; done < $symbol_file;

if [ -f $dlsym_file ];
then
    cat - <<EOF
         { "dlsym", (capsule_addr) _dlsym },
EOF
fi;

cat - <<EOF
         { NULL }
      };

    // and this is an aray of functions we must override in the DSOs
    // inside the capsule (mostly to take account of the fact that
    // they're pulled in from a tree with a filesystem prefix like /host)
    // NOTE: the shim address here isn't used, but we give it the same
    // value as the real function address so it's never accidentally
    // a value the capsule code will care about:
    capsule_item wrappers[] =
      {
        { "dlopen", (capsule_addr) _dlopen, (capsule_addr) _dlopen },
        { NULL }
      };

    symbol_ns = LM_ID_NEWLM;
    prefix = secure_getenv( "CAPSULE_PREFIX" );
    if( !prefix )
        prefix = "$proxy_tree";

    capsule_init();

    dso = capsule_dlmopen( "$proxied_dso", prefix, &symbol_ns, wrappers,
                           0, exclude, &capsule_errno, &capsule_error );

    if( dso )
    {
        capsule_relocate( "$proxied_dso", dso, 0, relocs, &capsule_error );
    }
    else
    {
        fprintf( stderr, "capsule_dlmopen() failed: %s\\n", capsule_error );
        exit( 1 );
    }
}
EOF

echo -n > $map_file;
exec >& $map_file;

for node in ${!NODE[@]};
do
    echo "$node {";
    echo "  global:";
    for symbol in ${NODE[$node]};
    do
        echo "    $symbol;";
    done;
    echo "};";
    echo;
done;

# scrub the (symbol version) map file if it's empty:
if [ ! -s $map_file ];
then
    rm -f $map_file;
fi;

mv "$proxy_src.tmp" "$proxy_src";
