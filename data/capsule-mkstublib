#!/bin/bash

# Copyright Â© 2017 Collabora Ltd

# This file is part of libcapsule.

# libcapsule is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of the
# License, or (at your option) any later version.

# libcapsule is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with libcapsule.  If not, see <http://www.gnu.org/licenses/>.

set -u
set -e

declare -A NODE;
top=$(dirname $0);
top=${top:-.};
me=$(basename $0);

usage ()
{
cat << EOF
Usage: $me [OPTIONS] TARGET EXCLUDES EXPORTS OUTPUT [DSO-VERSION [TREE]]"
    Options:
        --capsule-symbols=PATH  Use replacement capsule-symbols(1)
        --dlopen-implementation=PATH
                                An implementation of _dlopen()
                                [default: OUTPUT.dlopen]
        --dlsym-implementation=PATH
                                An implementation of _dlsym()
                                [default: OUTPUT.dlsym, if it exists]
        --symbols-from=PATH     Use symbols from this file
                                [default: \${OUTPUT%.c}.symbols]
        --[no-]update-symbols   Do or don't update symbols list if EXPORTS
                                is newer than it [default: do]
        --search-tree=PATH      Find libraries to be proxied in this
                                chroot, sysroot or container now
                                [default: TREE or /]
        --runtime-tree=PATH     Generated code will find proxied
                                libraries in this chroot, sysroot or
                                container at runtime if CAPSULE_PREFIX
                                is unset [default: TREE or /host]
    Positional parameters:
        TARGET                  SONAME of shared library to proxy,
                                for example libGL.so.1
        EXCLUDES                List of SONAMEs never loaded from TREE
                                in addition to libdl.so.2
        EXPORTS                 List of extra SONAMEs whose symbols are
                                to be exported from the shim, in addition
                                to TARGET itself
        OUTPUT                  C source code filename to output,
                                for example libGL.so.c
        DSO-VERSION             Major or MAJOR:MINOR:MICRO version (as for
                                libtool -version-number) to export, for
                                example 1 or 1:x:y for libGL.so.1
                                [default: parse SONAME]
        TREE                    Chroot or container to find libraries in,
                                both now and at runtime; overridden by
                                --runtime-tree and --search-tree
EOF
    exit "${1:-0}"
}

update_symbols=

getopt_temp="$(getopt -o 'h' \
    -l 'capsule-symbols:,search-tree:,runtime-tree:,dlopen-implementation:,dlsym-implementation:,symbols-from:,update-symbols,no-update-symbols,help' \
    -n "$me" -- "$@")"
eval set -- "$getopt_temp"

while true;
do
    case "$1" in
        (--capsule-symbols)
            CAPSULE_SYMBOLS="$2"
            shift 2;
            continue;
            ;;

        (--dlopen-implementation)
            dlopen_file="$2";
            shift 2;
            continue;
            ;;

        (--dlsym-implementation)
            dlsym_file="$2";
            shift 2;
            continue;
            ;;

        (--runtime-tree)
            runtime_tree="$2"
            shift 2;
            continue;
            ;;

        (--search-tree)
            search_tree="$2"
            shift 2;
            continue;
            ;;

        (--symbols-from)
            symbol_file="$2"
            shift 2;
            continue;
            ;;

        (--update-symbols)
            update_symbols=yes;
            shift;
            continue;
            ;;

        (--no-update-symbols)
            update_symbols=;
            shift;
            continue;
            ;;

        (--help|-h)
            usage 0;
            ;;

        (--)
            shift;
            break;
            ;;
        (*)
            echo "$me: Internal error" >&2;
            usage 2 >&2;
            ;;
    esac
done

: "${CAPSULE_SYMBOLS:="$top/capsule-symbols"}"

if [ "$#" -lt 4 ] || [ "$#" -gt 6 ];
then
    usage 2 >&2;
fi;

proxied_dso=$1;    shift;
proxy_excluded=$1; shift;
proxy_extra=$1;    shift;
proxy_src=$1;      shift;

if [ "$#" -gt 0 ];
then
    ltver=$1; shift;
fi

if [ "$#" -gt 0 ];
then
    proxy_tree=$1; shift;
else
    proxy_tree=
fi

if [ -n "${ltver:-}" ];
then
    major_version="${ltver%%:*}"
elif [ "x${proxied_dso%.so.*}" != "x$proxied_dso" ]; then
    major_version="${proxied_dso##*.so.}"
fi

: "${runtime_tree:="$proxy_tree"}"
: "${runtime_tree:=/host}"
: "${search_tree:="$proxy_tree"}"
: "${search_tree:=/}"

dso_base=${proxied_dso#lib}
dso_base=${dso_base%.so*}
proxied_dso=lib${dso_base}.so.${major_version};

map_file=${proxy_src%.c}.map;

if [ -z "${symbol_file:-}" ];
then
    symbol_file=${proxy_src%.c}.symbols;
fi

if [ -z "${dlopen_file:-}" ];
then
    # This is mandatory, so no test -f here
    dlopen_file=${proxy_src}.dlopen;
fi

if [ -z "${dlsym_file:-}" ] && [ -f "${proxy_src}.dlsym" ];
then
    dlsym_file="${proxy_src}.dlsym";
fi

sharedir=$(pkg-config --variable=makeinc capsule)

exec >$proxy_src.tmp;

cat $sharedir/capsule-shim.h

# generate the .symbols file if it doesn't exist, or if the proxy_extra
# control file has been updated:
if [ -n "$update_symbols" ] && [ $symbol_file -ot $proxy_extra ];
then
    echo -n > $symbol_file;
    if (for pt in $proxied_dso $(cat $proxy_extra);
        do
            if [ x$V = x1 ];
            then
                echo "  $CAPSULE_SYMBOLS $pt $search_tree" >&2;
            else
                echo "  SYMBOLS $pt $search_tree" >&2;
            fi;
            $CAPSULE_SYMBOLS $pt $search_tree || exit 1;
        done) > $symbol_file.tmp;
    then
        mv $symbol_file.tmp $symbol_file;
    else
        code=$?;
        rm $symbol_file.tmp
        exit $code;
    fi;
fi;


while read symbol version dependency;
do
    case $version in
        @*)
            echo "VERSIONED_STUB  ( $symbol, $version );";
            node=${version##*@};
            NODE[$node]=${NODE[$node]:-}" "$symbol;
            ;;
        *)
            echo "UNVERSIONED_STUB( $symbol );";
            ;;
    esac;
done < $symbol_file;

cat - <<EOF
static capsule cap;
static void *_dlsym (void *handle, const char *symbol);
static void *_ext_dlopen (const char *filename, int flag);

// should we exclude libpthread here?
// in any case, these are DSOs we do _not_ want to isolate
static const char *exclude[] = { // MUST NOT be pulled from the capsule
                                 // prefixed filesystem tree:
                                 "libdl.so.2",
EOF

while read excluded x;
do
    case $excluded in lib*) printf "%32s \"%s\",\n" "" $excluded; ;; esac;
done < $proxy_excluded;

cat - <<EOF
                                 NULL };

// -------------------------------------------------------------
// this is an array of the functions we want to act as a shim for:
static capsule_item relocs[] =
{
EOF

while read sym x;
do
    cat - <<EOF
  { "$sym" },
EOF
done < $symbol_file;

if [ -n "$dlsym_file" ];
then
    cat - <<EOF
  { "dlsym", (capsule_addr) _dlsym },
EOF
fi;

cat - <<EOF
  { NULL }
};

static const char *invalid_dl_reloc_targets[] =
{
  "$proxied_dso",
  "libc.so",
  "libdl.so",
  "libpthread.so",
  "libcapsule.so",
  NULL
};

// DSOs to restrict dlsym lookups to:    
static const char *valid_dlsym_sources[] =
{
  "$proxied_dso",
EOF

if [ -f "${proxy_extra}" ];
then
    for pt in $(cat $proxy_extra);
    do
        cat - <<EOF
  "$pt",
EOF
    done;
fi;

cat - <<EOF
  NULL
};
EOF

if [ -f ${dlopen_file} ];
then
    cat - <<EOF
static capsule_item dl_relocs[] =
{
  { "dlopen", (capsule_addr) _ext_dlopen, (capsule_addr) _ext_dlopen },
  { NULL }
};
EOF
else
    cat - <<EOF
static capsule_item dl_relocs[] =
{
  { NULL }
};
EOF
fi;

if [ -n "${dlsym_file}" ];
then
    cat - <<EOF
// -------------------------------------------------------------
// start of ${proxy_src%.c} dlsym wrapper
EOF
    cat $dlsym_file;
    cat - <<EOF
// end of ${proxy_src%.c} dlsym wrapper
// -------------------------------------------------------------
EOF
fi

if [ -f ${dlopen_file} ];
then
    cat - <<EOF
// -------------------------------------------------------------
// start of ${proxy_src%.c} dlopen wrapper
EOF
    cat $dlopen_file;
    cat - <<EOF
// end of ${proxy_src%.c} dlopen wrapper
// -------------------------------------------------------------
EOF
fi

cat - <<EOF
static void __attribute__ ((constructor)) _capsule_init (void)
{
    int   capsule_errno = 0;
    char *capsule_error = NULL;
    const char *prefix;
    Lmid_t symbol_ns;
    void * dso;

    // and this is an aray of functions we must override in the DSOs
    // inside the capsule (mostly to take account of the fact that
    // they're pulled in from a tree with a filesystem prefix like /host)
    // NOTE: the shim address here isn't used, but we give it the same
    // value as the real function address so it's never accidentally
    // a value the capsule code will care about:
    capsule_item wrappers[] =
      {
        { "dlopen", (capsule_addr) _int_dlopen, (capsule_addr) _int_dlopen },
        { NULL }
      };

    symbol_ns = LM_ID_NEWLM;
    prefix = secure_getenv( "CAPSULE_PREFIX" );
    if( !prefix )
        prefix = "$runtime_tree";

    cap = capsule_init( symbol_ns, prefix, exclude, valid_dlsym_sources );

    dso = capsule_load( cap, "$proxied_dso", &symbol_ns, wrappers,
                        &capsule_errno, &capsule_error );

    if( dso )
    {
        int rloc = capsule_relocate( cap, relocs, &capsule_error );

        if( rloc == 0 )
        {
            capsule_relocate_except( cap, dl_relocs,
                                     &invalid_dl_reloc_targets[0],
                                     &capsule_error );
        }
    }
    else
    {
        fprintf( stderr, "capsule_dlmopen() failed: %s\\n", capsule_error );
        exit( 1 );
    }
}
EOF

echo -n > $map_file;
exec >& $map_file;

for node in ${!NODE[@]};
do
    echo "$node {";
    echo "  global:";
    for symbol in ${NODE[$node]};
    do
        echo "    $symbol;";
    done;
    echo "};";
    echo;
done;

# scrub the (symbol version) map file if it's empty:
if [ ! -s $map_file ];
then
    rm -f $map_file;
fi;

mv "$proxy_src.tmp" "$proxy_src";
